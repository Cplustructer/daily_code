/*输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。*/
class Solution {
public:
	TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		return reConstruct(pre, vin);
	}
	TreeNode* reConstruct(const vector<int>& pre, const vector<int>& vin){
		if (pre.empty()){                      //判空
			return NULL;
		}
		int rootvalue = pre[0];
		TreeNode* ptr = new TreeNode(rootvalue);      //根
		auto vindex = find(vin.begin(), vin.end(), rootvalue);     //在中序里找到根的位置
		int leftsize = vindex - vin.begin();                      //左子树在中序中占的结点个数
		ptr->left = reConstruct(vector<int>(pre.begin() + 1, pre.begin() + 1 + leftsize),
			vector<int>(vin.begin(), vin.begin() + leftsize));//建立左子树
		ptr->right = reConstruct(vector<int>(pre.begin() + 1 + leftsize, pre.end()),
			vector<int>(vin.begin() + leftsize + 1, vin.end()));//建立右子树
		return ptr;
	}
};